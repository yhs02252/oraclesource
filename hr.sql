-- EMPLOYESS (scott 계정의 emp 테이블 원본)
-- EMPLOYESS 전체 조회
SELECT * FROM EMPLOYEES e;

-- EMPLOYESS 의 first_name, last_name, job_id 조회
SELECT
	FIRST_NAME,
	LAST_NAME,
	JOB_ID
FROM
	EMPLOYEES e;

--사원번호가 176인 사원의 LAST_NAME, 부서번호 조회
SELECT LAST_NAME, DEPARTMENT_ID, EMPLOYEE_ID FROM EMPLOYEES e WHERE EMPLOYEE_ID = 176;


--연봉이 12000 이상 되는 직원들의 LAST_NAME 과 연봉 조회
SELECT LAST_NAME, SALARY FROM EMPLOYEES e WHERE SALARY >= 12000;


--연봉이 5000 에서 12000 범위가 아닌 사람들의 LAST_NAME 과 연봉
SELECT LAST_NAME, SALARY FROM EMPLOYEES e WHERE SALARY < 5000 OR SALARY >12000

--20번 혹은 50번 부서에서 근무하는 사원들의 LAST_NAME, 부서번호를 조회
--단 이름의 오름차순, 부서의 오름차순으로 정렬
SELECT
	LAST_NAME,
	DEPARTMENT_ID
FROM
	EMPLOYEES e
WHERE
	DEPARTMENT_ID IN (50, 20)
ORDER BY
	LAST_NAME ASC,
	DEPARTMENT_ID ASC ;


--커미션을 버는 사원들의 LAST_NAME, SALARY, COMMISSION_PCT를 조회
--단 연봉의 내림차순, 커미션 내림차순으로 정렬
SELECT
	LAST_NAME,
	SALARY,
	COMMISSION_PCT
FROM
	EMPLOYEES e
WHERE
	COMMISSION_PCT != 0
ORDER BY
	SALARY DESC,
	COMMISSION_PCT DESC;


--연봉이 2500,3500,7000이 아니며 JOB_ID가 SA_REP OR ST_SLERK인 사원 조회
SELECT
	*
FROM
	EMPLOYEES e
WHERE
	SALARY NOT IN (2500, 3500, 7000) AND 
	JOB_ID IN('SA_REP', 'ST_SLERK');
	

--2018/02/20~2018/05/01 사이에 고용된 직원들의 LAST_NAME,사번,고용일자(HIRE) 조회
SELECT
	LAST_NAME ,
	EMPLOYEE_ID ,
	HIRE_DATE
FROM
	EMPLOYEES e
WHERE
	HIRE_DATE >= '2018-02-20'
	AND HIRE_DATE <= '2018-05-01';


--2015년에 고용된 사원 조회
SELECT *
FROM EMPLOYEES e 
WHERE HIRE_DATE >= '2015-01-01' AND HIRE_DATE <= '2015-12-31';

--20번 혹은 50번 부서에서 근무하며, 연봉이 5000 ~ 12000 사이인 직원들의 FIRST_NAME, LAST_NAME, 연봉조회(연봉 오름차순)
SELECT FIRST_NAME, LAST_NAME, SALARY FROM EMPLOYEES e WHERE DEPARTMENT_ID IN (20,50) AND SALARY BETWEEN 5000 AND 12000 ORDER BY SALARY ASC ;

--연봉 5000~12000사이가 아닌 직원들의 정보 조회
SELECT FIRST_NAME, LAST_NAME, SALARY FROM EMPLOYEES e WHERE SALARY NOT BETWEEN 5000 AND 12000;

--2018/02/20~2018/05/01 사이에 고용된 직원들의 LAST_NAME,사번,고용일자(HIRE) 조회
SELECT LAST_NAME ,EMPLOYEE_ID ,HIRE_DATE
FROM EMPLOYEES e
WHERE HIRE_DATE BETWEEN '2018-02-20' AND '2018-05-01';


--LIKE
--LAST_NAME 에 U 가 포함되는 사원들의 사번, LAST_NAME 조회
SELECT EMPLOYEE_ID , LAST_NAME 
FROM EMPLOYEES e 
WHERE LAST_NAME LIKE '%u%';

--LAST_NAME 에 네번째 글자가 A 인 사원들의 사번, LAST_NAME 조회
SELECT EMPLOYEE_ID, LAST_NAME 
FROM EMPLOYEES e
WHERE LAST_NAME LIKE '___a%';

--LAST_NAME 에 A 혹은 E 글자가 포함되는 사원들의 사번, LAST_NAME 조회(단, LAST_NAME 오름차순)
SELECT EMPLOYEE_ID , LAST_NAME 
FROM EMPLOYEES e 
WHERE LAST_NAME LIKE '%a%' OR LAST_NAME LIKE '%e%'
ORDER BY LAST_NAME DESC;

--LAST_NAME 에 A 와 E 글자가 포함되는 사원들의 사번, LAST_NAME 조회(단, LAST_NAME 오름차순)
SELECT EMPLOYEE_ID , LAST_NAME 
FROM EMPLOYEES e 
WHERE LAST_NAME LIKE '%a%' AND LAST_NAME LIKE '%e%'
ORDER BY LAST_NAME DESC;

--IS NULL
--MANAGER ID 가 NULL 인 사원들의 LAST_NAME 및 JOB_ID 조회
SELECT LAST_NAME, JOB_ID FROM EMPLOYEES e WHERE e.MANAGER_ID IS NULL;

--JOB_ID가 ST_CLERK가 아닌 사원이 없는 부서 조회
--단, 부서 번호가 NULL인 경우는 제외한다.
SELECT DISTINCT DEPARTMENT_ID FROM EMPLOYEES e WHERE JOB_ID != 'ST_CLERK' AND e.DEPARTMENT_ID IS NOT NULL;

--COMMISSION_PCT가 NULL이 아닌 사원들 중에서 COMMISSION = SALARY *  COMMISSION_PCT를 구한다
-- 사원번호, FIRST_NAME, JOB_ID 와 함께 조회
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY, COMMISSION_PCT, SALARY * COMMISSION_PCT AS COMMISION FROM EMPLOYEES e WHERE COMMISSION_PCT IS NOT NULL;

--부서 80의 사원에 적용 가능한 세율 표시하기
--LAST_NAME, SALARY, TAX_RATE 출력
--TAX_RATE는 SALARY / 2000으로 나눈 후 버림
-- 해당 값이 0이면 0.0 /1, 0.09/ 2, 0.20 / 3, 0.30/ 4, 0.40 / 5, 0.42 / 6, 0.44/ 그 외 0.45

SELECT LAST_NAME , SALARY ,DEPARTMENT_ID , DECODE(TRUNC(SALARY/2000) , 0 , 0.0 ,1, 0.09,  2, 0.20 , 3, 0.30, 4, 0.40 , 5, 0.42 , 6, 0.44, 0.45 ) AS TAX_RATE
FROM EMPLOYEES e WHERE DEPARTMENT_ID = 80;


--회사내의 최대 연봉 및 최소 연봉의 차이를 출력
SELECT MAX(SALARY)-MIN(SALARY) AS SAL_GAP FROM EMPLOYEES e ;

--매니저로 근무하는 사원들의 총 숫자를 출력
SELECT COUNT(DISTINCT MANAGER_ID) FROM EMPLOYEES e ;

--매니저가 없는 사원들은 제외하고 각 매니저가 관리하는 사원들 중에서 최소 급여를 받는 사원 조회
--매니저가 관리하는 사원 중에서 연봉이 6000 미만 제외
SELECT MANAGER_ID, MIN(SALARY) AS 최소급여 FROM EMPLOYEES e GROUP BY MANAGER_ID HAVING MANAGER_ID IS NOT NULL AND MIN(SALARY) >= 6000;

--JOIN
--자신의 담당 매니저의 고용일보다 빠른 입사자 칮기
--사원번호, 입사일, 이름(LAST_NAME), 매니저아이디 출력
--SELF 조인

SELECT
	e1.EMPLOYEE_ID,
	E1.HIRE_DATE,
	E1.LAST_NAME,
	E1.MANAGER_ID 
FROM
	EMPLOYEES e1
LEFT OUTER JOIN EMPLOYEES e2 ON
	E2.EMPLOYEE_ID = E1.MANAGER_ID
WHERE E1. HIRE_DATE < E2.HIRE_DATE 


--도시이름이 T로 시작하는 지역에 사는 사원들의 정보 조회
--사원번호, 이름(LAST_NAME), 부서번호, 지역명
--EMPLOYEES, DEPARTMENT, LOCATIONS 조인
SELECT
	E.EMPLOYEE_ID,
	E.LAST_NAME,
	E.DEPARTMENT_ID,
	L.CITY
FROM
	EMPLOYEES e
JOIN DEPARTMENTS d ON
	E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS l ON
	D.LOCATION_ID = L.LOCATION_ID
WHERE 
	SUBSTR(L.CITY, 1) LIKE 'T%'; 

--각 부서별 사원 수, 평균 연봉(소수점 2자리까지)조회
--부서명, 부서위치아이디, 부서별 사원수, 평균 연봉 출력
--EMPLOYEES, DEPARTMANT 조인
SELECT
	D.DEPARTMENT_NAME,
	D.DEPARTMENT_ID,
	COUNT(E.DEPARTMENT_ID),
	ROUND(AVG(E.SALARY), 2)
FROM
	EMPLOYEES e
JOIN DEPARTMENTS d ON
	E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY
	D.DEPARTMENT_NAME ,
	D.DEPARTMENT_ID; 


--EXECUTIVE 부서에 근무하는 모든 사원들의 부서번호, 이름(LAST_NAME), JOB_ID조회
--EMPLOYEES, DEPARTMANT 조인
SELECT
	E.DEPARTMENT_ID,
	E.LAST_NAME,
	E.JOB_ID,
	D.DEPARTMENT_NAME
FROM
	EMPLOYEES e
JOIN DEPARTMENTS d ON
	E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE
	D.DEPARTMENT_NAME = 'Executive';

--기존의 직무를 계속 하고 있는 사원 조회
--사원번호, JOB_ID 출력
--EMPLOYEES, JOB_HISTORY 조인
SELECT
	DISTINCT E.EMPLOYEE_ID,
	E.JOB_ID 
FROM
	EMPLOYEES e
JOIN JOB_HISTORY jh ON
	E.EMPLOYEE_ID != JH.EMPLOYEE_ID
WHERE
	E.DEPARTMENT_ID = JH.DEPARTMENT_ID AND
	E.JOB_ID = JH.JOB_ID 
ORDER BY E.EMPLOYEE_ID ;



--각 사원별 소속부서에서 자신보다 늦게 고용되었으나 많은 급여를 받는 사원의 정보 조회
--부서번호, FIRST_NAME과 LAST_NAME을 연결하여 출력, 급여, 입사일 출력
--EMPLOYEES SELF조인
SELECT
	E1. DEPARTMENT_ID,
	CONCAT(E1.FIRST_NAME, E1.LAST_NAME) AS "EMPLOYEES NAME",
	E1.SALARY,
	E1.HIRE_DATE,
	CONCAT(E2.FIRST_NAME, E2.LAST_NAME) AS "EMPLOYEES NAME",
	E2.SALARY,
	E2.HIRE_DATE,
	E2.DEPARTMENT_ID 
FROM
	EMPLOYEES e1
LEFT OUTER JOIN EMPLOYEES e2 ON
	E1.DEPARTMENT_ID = E2.DEPARTMENT_ID
WHERE
	E1.HIRE_DATE < E2.HIRE_DATE
	AND E1.SALARY < E2.SALARY
ORDER BY CONCAT(E1.FIRST_NAME, E1.LAST_NAME), E2.HIRE_DATE ;


--서브쿼리로 작성
--EXECUTIVE 부서에 근무하는 모든 사원들의 부서번호, 이름(LAST_NAME), JOB_ID조회
SELECT
	E.DEPARTMENT_ID,
	E.LAST_NAME,
	E.JOB_ID
FROM
	EMPLOYEES e
WHERE
	(E.DEPARTMENT_ID,
	'Executive') IN (
	SELECT
		D.DEPARTMENT_ID,
		D.DEPARTMENT_NAME
	FROM
		DEPARTMENTS d);
