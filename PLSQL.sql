--실행결과를 화면에 출력
--SET SERVEROUTPUT ON;

--PL/SQL : 데이터베이스 관련 특정 작업을 수행하는 명령어 / 선언문을 모아둔 블럭
--SQL + 프로그래밍

--블록
--DECLARE
--  변수 선언(선택)
--BEGIN
--  조건문, 반복문, SELECT, DML, 함수
--EXCEPTION
--  오류 처리
--END;


BEGIN
	DBMS_OUTPUT.PUT_LINE('HELLO PL/SQL');
END;

--변수
--테이블 / 컬럼명 짓는 규칙과 같음
--숫자 : NUMBER / 문자 : VARCHAR2 / 날짜 : DATE / 논리 : BOOLEAN

DECLARE
	V_EMPNO NUMBER(4) := 7788;
	V_ENAME VARCHAR2(10);
BEGIN
	V_ENAME := 'SCOTT';
--	DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_EMPNO);
	DBMS_OUTPUT.PUT_LINE('V_ENAME : ' || V_ENAME);
END;
/

--상수 선언

DECLARE
	V_TAX CONSTANT NUMBER(1) := 7;
BEGIN
	DBMS_OUTPUT.PUT_LINE('V_TAX : ' || V_TAX);
END;
/

--변수의 기본값 지정

DECLARE
	V_TAX NUMBER(2) DEFAULT 10;
BEGIN
	DBMS_OUTPUT.PUT_LINE('V_TAX : ' || V_TAX);
END;
/

--변수의 NULL 값 저장 막기

DECLARE
--	V_TAX NUMBER(2) DEFAULT 10;
	V_TAX NUMBER(2) NOT NULL :=20;
BEGIN
	DBMS_OUTPUT.PUT_LINE('V_TAX : ' || V_TAX);
END;
/

--참조형(특정 테이블 열의 자료형, 행 하나의 자료 구조 참조)
DECLARE
	V_DEPTNO DEPT.DEPTNO%TYPE :=20;
BEGIN
	DBMS_OUTPUT.PUT_LINE('V_DEPTNO : ' || V_DEPTNO);
END;
/

DECLARE
	V_DEPT_ROW DEPT%ROWTYPE;
BEGIN
	SELECT DEPTNO,DNAME,LOC INTO V_DEPT_ROW
	FROM DEPT
	WHERE DEPTNO = 40;
	DBMS_OUTPUT.PUT_LINE('DEPTNO : ' || V_DEPT_ROW.DEPTNO);
	DBMS_OUTPUT.PUT_LINE('DNAME : ' || V_DEPT_ROW.DNAME);
	DBMS_OUTPUT.PUT_LINE('LOC : ' || V_DEPT_ROW.LOC);
END;
/

--조건문
--IF ~ THEN
--IF ~ THEN ~ ELSE
--IF ~ THEN ~ ELSIF ~ ELSE

--변수의 값이 홀/짝 구분
DECLARE
	V_NUMBER NUMBER := 15;
BEGIN
	IF MOD(V_NUMBER,2) = 1 THEN
		DBMS_OUTPUT.PUT_LINE('V_NUMBER : ' || V_NUMBER || '홀수');
	END IF;
END;
/

--~ELSE
DECLARE
	V_NUMBER NUMBER := 18;
BEGIN
	IF MOD(V_NUMBER,2) = 1 THEN
		DBMS_OUTPUT.PUT_LINE('V_NUMBER : ' || V_NUMBER || '홀수');
	ELSE
		DBMS_OUTPUT.PUT_LINE('V_NUMBER : ' || V_NUMBER || '짝수');
	END IF;
END;
/

-- >=90 A, >=80 B, >=70 C, >=60 D, F
DECLARE
	V_NUMBER NUMBER := 77;
BEGIN
	IF V_NUMBER >= 90 THEN
		DBMS_OUTPUT.PUT_LINE('A');
	ELSIF
		V_NUMBER >= 80 THEN
		DBMS_OUTPUT.PUT_LINE('B');
	ELSIF
		V_NUMBER >= 70 THEN
		DBMS_OUTPUT.PUT_LINE('C');
	ELSIF
		V_NUMBER >= 60 THEN
		DBMS_OUTPUT.PUT_LINE('D');
	ELSE
		DBMS_OUTPUT.PUT_LINE('F');
	END IF;
END;
/

--CASE 문
DECLARE
	V_NUMBER NUMBER := 77;
BEGIN
	CASE TRUNC(V_NUMBER/10)
		WHEN 10 THEN DBMS_OUTPUT.PUT_LINE('A');
		WHEN 9 THEN DBMS_OUTPUT.PUT_LINE('A');
		WHEN 8 THEN DBMS_OUTPUT.PUT_LINE('B');
		WHEN 7 THEN DBMS_OUTPUT.PUT_LINE('C');
		WHEN 6 THEN DBMS_OUTPUT.PUT_LINE('D');
		ELSE DBMS_OUTPUT.PUT_LINE('F');
	END CASE;
END;
/


--LOOP ~ END LOOP
--WHILE ~ LOOP ~ END LOOP
--FOR ~ IN ~ LOOP ~ END LOOP

--종료
--EXIT
--EXIT WHEN 
--CONTINUE
--CONTINUE WHEN

DECLARE
	V_NUM NUMBER := 0;
BEGIN
	LOOP
		DBMS_OUTPUT.PUT_LINE('V_NUM : ' || V_NUM);
		V_NUM := V_NUM + 1;
		EXIT WHEN V_NUM > 4;
	END LOOP;
END;
/

DECLARE
	V_NUM NUMBER := 0;
BEGIN
	LOOP
		DBMS_OUTPUT.PUT_LINE('V_NUM : ' || V_NUM);
		V_NUM := V_NUM + 1;
		IF V_NUM > 4 THEN
			EXIT;
		END IF;
	END LOOP;
END;
/

DECLARE
	V_NUM NUMBER := 0;
BEGIN
	WHILE  V_NUM < 4 LOOP
		DBMS_OUTPUT.PUT_LINE('V_NUM : ' || V_NUM);
		V_NUM := V_NUM + 1;
	END LOOP;
END;
/


BEGIN
	FOR i IN 0..4 LOOP
		DBMS_OUTPUT.PUT_LINE('i : ' || i);
	END LOOP;
END;
/

BEGIN
	FOR i IN REVERSE 0..4 LOOP
		DBMS_OUTPUT.PUT_LINE('i : ' || i);
	END LOOP;
END;
/

--숫자 1부터 10까지 숫자 중에서 홀수만 출력

BEGIN
	FOR NUM IN 1..10 LOOP
	IF MOD(NUM,2) = 1 THEN
		DBMS_OUTPUT.PUT_LINE('NUM : ' || NUM);
	END IF;
END LOOP;
END;
/


--커서(CURSOR) : SELECT 문 또는 DML 과 같은 SQL 구문 실행했을 때,
--해당 SQL을 처리하는 정보를 저장한 메모리 공간

--SELECT INTO : 조회 결과가 하나일 때 사용
DECLARE
	V_DEPT_ROW DEPT%ROWTYPE;
BEGIN
	SELECT DEPTNO,DNAME,LOC INTO V_DEPT_ROW
	FROM DEPT
	WHERE DEPTNO = 40;
	DBMS_OUTPUT.PUT_LINE('DEPTNO : ' || V_DEPT_ROW.DEPTNO);
	DBMS_OUTPUT.PUT_LINE('DNAME : ' || V_DEPT_ROW.DNAME);
	DBMS_OUTPUT.PUT_LINE('LOC : ' || V_DEPT_ROW.LOC);
END;
/

--조회 결과가 여러개의 행일 때
--명시적 커서
--1) 커서 선언
--2) 커서를 연다
--3) FETCH (커서에서 읽어온 데이터를 사용)
--4) 커서 닫기

DECLARE
	V_DEPT_ROW DEPT%ROWTYPE;

	--명시적 커서 선언
	CURSOR C1 IS
		SELECT DEPTNO,DNAME,LOC
		FROM DEPT
		WHERE DEPTNO = 40;
BEGIN
	--커서 열기
	OPEN C1;

	--FETCH
	FETCH C1 INTO V_DEPT_ROW;

	DBMS_OUTPUT.PUT_LINE('DEPTNO : ' || V_DEPT_ROW.DEPTNO);
	DBMS_OUTPUT.PUT_LINE('DNAME : ' || V_DEPT_ROW.DNAME);
	DBMS_OUTPUT.PUT_LINE('LOC : ' || V_DEPT_ROW.LOC);

	--커서 닫기
	CLOSE C1;
END;
/

--여러 행일 때
DECLARE
	V_DEPT_ROW DEPT%ROWTYPE;

	--명시적 커서 선언
	CURSOR C1 IS
		SELECT DEPTNO,DNAME,LOC
		FROM DEPT;
BEGIN
	--커서 열기
	OPEN C1;

	LOOP
		--FETCH
		FETCH C1 INTO V_DEPT_ROW;
	
		EXIT WHEN C1%NOTFOUND;
	
		DBMS_OUTPUT.PUT_LINE('DEPTNO : ' || V_DEPT_ROW.DEPTNO 
						|| ' DNAME : ' || V_DEPT_ROW.DNAME 
						|| ' LOC : ' || V_DEPT_ROW.LOC);
		
	END LOOP;
	
	--커서 닫기
	CLOSE C1;
END;
/

DECLARE
	--명시적 커서 선언
	CURSOR C1 IS
		SELECT DEPTNO, DNAME, LOC
		FROM DEPT;
BEGIN
	--커서 OPEN, FETCH, CLOSE 자동으로 실행
	FOR C1_ROW IN C1 LOOP
		DBMS_OUTPUT.PUT_LINE('DEPTNO : ' || C1_ROW.DEPTNO 
						|| ' DNAME : ' || C1_ROW.DNAME 
						|| ' LOC : ' || C1_ROW.LOC);
		
	END LOOP;
END;
/

--예외

DECLARE
	V_TAX NUMBER(1);
BEGIN
	SELECT DNAME INTO V_TAX
	FROM DEPT
	WHERE DEPTNO = 10;
EXCEPTION
	WHEN VALUE_ERROR THEN
		DBMS_OUTPUT.PUT_LINE('예외 처리 : 수치 또는 값 오류 발생');
END;
/

--저장 서브 프로그램
--1) 프로시저
--2) 트리거

CREATE OR REPLACE PROCEDURE PRO_NOPARAM
IS 
	V_EMPNO NUMBER (4) := 7788;
	V_ENAME VARCHAR2(10);
BEGIN
	V_ENAME := 'SCOTT';
	DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_EMPNO);
	DBMS_OUTPUT.PUT_LINE('V_ENAME : ' || V_ENAME);
END;
/

--프로시저를 익명 블록에서 실행
--SQL PLUS
-- =>EXECUTE PRO_NOPARAM

BEGIN
	PRO_NOPARAM;
END;

--트리거 : 데이터베이스 안의 특정 상황이나 동작, 이벤트가 발생하는 경우 자동으로 실행되는 기능 정의
--1) DML 트리거 : INSERT, UPDATE, DELETE 와 같은 DML 명령어를 기점으로 동작
--2) DDL 트리거 / 시스템 트리거 / 단순 트리거...

CREATE TABLE EMP_TRG
AS SELECT * FROM EMP;

--트리거 생성
--RAISE_APPLICATION_ERROR(오류코드번호, '메세지') : 강제 EXCEPTION
--오류코드번호 : -20000 ~ -20999 범위 사용 가능
CREATE OR REPLACE TRIGGER TRG_NODML_WEEKEND
BEFORE -- INSERT OR UPDATE OR DELETE <- 이것들이 시작되기 전에 확인하라는 구문
INSERT OR UPDATE OR DELETE ON EMP_TRG
BEGIN
	IF TO_CHAR(SYSDATE, 'DY') IN ('토', '일') THEN
		IF INSERTING THEN 
			RAISE_APPLICATION_ERROR(-20000, '주말 사원 정보 추가 불가');
		ELSIF UPDATING THEN 
			RAISE_APPLICATION_ERROR(-20001, '주말 사원 정보 수정 불가');
		ELSIF DELETING THEN 
			RAISE_APPLICATION_ERROR(-20002, '주말 사원 정보 삭제 불가');
		ELSE  
			RAISE_APPLICATION_ERROR(-20003, '주말 사원 정보 변경 불가');
		END IF;
	END IF;
END;

UPDATE EMP_TRG SET SAL = 2700 WHERE EMPNO = 7844;

SELECT * FROM EMP_TRG;


CREATE TABLE EMP_TRG_LOG( 
	TABLENAME VARCHAR2(10),		-- DML 이 수행된 테이블 명
	DML_TYPE VARCHAR2(10),		-- DML 명령어 종류
	EMPNO NUMBER(4),		    -- DML 대상이 된 사원번호
	USER_NAME VARCHAR2(30),		-- DML 을 수행한 USER 이름
	CHANGE_DATE DATE			-- DML이 수행된 날짜
);

CREATE OR REPLACE TRIGGER TRG_EMP_LOG
AFTER  -- INSERT OR UPDATE OR DELETE ON <- 이것들이 시작된 후에 확인하라는 구문
INSERT OR UPDATE OR DELETE ON EMP_TRG
FOR EACH ROW 

BEGIN 
	IF INSERTING THEN 
		INSERT INTO EMP_TRG_LOG
		VALUES ('EMP_TRG','INSERT', :NEW.EMPNO, SYS_CONTEXT('USERENV','SESSION_USER'), SYSDATE);
	ELSIF UPDATING THEN 
		INSERT INTO EMP_TRG_LOG
		VALUES ('EMP_TRG','UPDATE', :OLD.EMPNO, SYS_CONTEXT('USERENV','SESSION_USER'), SYSDATE);
	ELSIF DELETING THEN 
		INSERT INTO EMP_TRG_LOG
		VALUES ('EMP_TRG','DELETE', :OLD.EMPNO, SYS_CONTEXT('USERENV','SESSION_USER'), SYSDATE);
	END IF;
END;

INSERT INTO EMP_TRG
VALUES(9999,'TESTEMP','CLERK',7788,'2018-02-02',1200,NULL,20);

SELECT * FROM EMP_TRG_LOG;

--트리거 제거
DROP TRIGGER TRG_NODML_WEEKEND;
