--실행결과를 화면에 출력
--SET SERVEROUTPUT ON;

--PL/SQL : 데이터베이스 관련 특정 작업을 수행하는 명령어 / 선언문을 모아둔 블럭
--SQL + 프로그래밍

--블록
--DECLARE
--  변수 선언(선택)
--BEGIN
--  조건문, 반복문, SELECT, DML, 함수
--EXCEPTION
--  오류 처리
--END;


BEGIN
	DBMS_OUTPUT.PUT_LINE('HELLO PL/SQL');
END;

--변수
--테이블 / 컬럼명 짓는 규칙과 같음
--숫자 : NUMBER / 문자 : VARCHAR2 / 날짜 : DATE / 논리 : BOOLEAN

DECLARE
	V_EMPNO NUMBER(4) := 7788;
	V_ENAME VARCHAR2(10);
BEGIN
	V_ENAME := 'SCOTT';
--	DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_EMPNO);
	DBMS_OUTPUT.PUT_LINE('V_ENAME : ' || V_ENAME);
END;
/

--상수 선언

DECLARE
	V_TAX CONSTANT NUMBER(1) := 7;
BEGIN
	DBMS_OUTPUT.PUT_LINE('V_TAX : ' || V_TAX);
END;
/

--변수의 기본값 지정

DECLARE
	V_TAX NUMBER(2) DEFAULT 10;
BEGIN
	DBMS_OUTPUT.PUT_LINE('V_TAX : ' || V_TAX);
END;
/

--변수의 NULL 값 저장 막기

DECLARE
--	V_TAX NUMBER(2) DEFAULT 10;
	V_TAX NUMBER(2) NOT NULL :=20;
BEGIN
	DBMS_OUTPUT.PUT_LINE('V_TAX : ' || V_TAX);
END;
/

--참조형(특정 테이블 열의 자료형, 행 하나의 자료 구조 참조)
DECLARE
	V_DEPTNO DEPT.DEPTNO%TYPE :=20;
BEGIN
	DBMS_OUTPUT.PUT_LINE('V_DEPTNO : ' || V_DEPTNO);
END;
/

DECLARE
	V_DEPT_ROW DEPT%ROWTYPE;
BEGIN
	SELECT DEPTNO,DNAME,LOC INTO V_DEPT_ROW
	FROM DEPT
	WHERE DEPTNO = 40;
	DBMS_OUTPUT.PUT_LINE('DEPTNO : ' || V_DEPT_ROW.DEPTNO);
	DBMS_OUTPUT.PUT_LINE('DNAME : ' || V_DEPT_ROW.DNAME);
	DBMS_OUTPUT.PUT_LINE('LOC : ' || V_DEPT_ROW.LOC);
END;
/

--조건문
--IF ~ THEN
--IF ~ THEN ~ ELSE
--IF ~ THEN ~ ELSIF ~ ELSE

--변수의 값이 홀/짝 구분
DECLARE
	V_NUMBER NUMBER := 15;
BEGIN
	IF MOD(V_NUMBER,2) = 1 THEN
		DBMS_OUTPUT.PUT_LINE('V_NUMBER : ' || V_NUMBER || '홀수');
	END IF;
END;
/

--~ELSE
DECLARE
	V_NUMBER NUMBER := 18;
BEGIN
	IF MOD(V_NUMBER,2) = 1 THEN
		DBMS_OUTPUT.PUT_LINE('V_NUMBER : ' || V_NUMBER || '홀수');
	ELSE
		DBMS_OUTPUT.PUT_LINE('V_NUMBER : ' || V_NUMBER || '짝수');
	END IF;
END;
/

-- >=90 A, >=80 B, >=70 C, >=60 D, F
DECLARE
	V_NUMBER NUMBER := 77;
BEGIN
	IF V_NUMBER >= 90 THEN
		DBMS_OUTPUT.PUT_LINE('A');
	ELSIF
		V_NUMBER >= 80 THEN
		DBMS_OUTPUT.PUT_LINE('B');
	ELSIF
		V_NUMBER >= 70 THEN
		DBMS_OUTPUT.PUT_LINE('C');
	ELSIF
		V_NUMBER >= 60 THEN
		DBMS_OUTPUT.PUT_LINE('D');
	ELSE
		DBMS_OUTPUT.PUT_LINE('F');
	END IF;
END;
/

--CASE 문
DECLARE
	V_NUMBER NUMBER := 77;
BEGIN
	CASE TRUNC(V_NUMBER/10)
		WHEN 10 THEN DBMS_OUTPUT.PUT_LINE('A');
		WHEN 9 THEN DBMS_OUTPUT.PUT_LINE('A');
		WHEN 8 THEN DBMS_OUTPUT.PUT_LINE('B');
		WHEN 7 THEN DBMS_OUTPUT.PUT_LINE('C');
		WHEN 6 THEN DBMS_OUTPUT.PUT_LINE('D');
		ELSE DBMS_OUTPUT.PUT_LINE('F');
	END CASE;
END;
/


--LOOP ~ END LOOP
--WHILE ~ LOOP ~ END LOOP
--FOR ~ IN ~ LOOP ~ END LOOP

--종료
--EXIT
--EXIT WHEN 
--CONTINUE
--CONTINUE WHEN

DECLARE
	V_NUM NUMBER := 0;
BEGIN
	LOOP
		DBMS_OUTPUT.PUT_LINE('V_NUM : ' || V_NUM);
		V_NUM := V_NUM + 1;
		EXIT WHEN V_NUM > 4;
	END LOOP;
END;
/

DECLARE
	V_NUM NUMBER := 0;
BEGIN
	LOOP
		DBMS_OUTPUT.PUT_LINE('V_NUM : ' || V_NUM);
		V_NUM := V_NUM + 1;
		IF V_NUM > 4 THEN
			EXIT;
		END IF;
	END LOOP;
END;
/

DECLARE
	V_NUM NUMBER := 0;
BEGIN
	WHILE  V_NUM < 4 LOOP
		DBMS_OUTPUT.PUT_LINE('V_NUM : ' || V_NUM);
		V_NUM := V_NUM + 1;
	END LOOP;
END;
/


BEGIN
	FOR i IN 0..4 LOOP
		DBMS_OUTPUT.PUT_LINE('i : ' || i);
	END LOOP;
END;
/

BEGIN
	FOR i IN REVERSE 0..4 LOOP
		DBMS_OUTPUT.PUT_LINE('i : ' || i);
	END LOOP;
END;
/

--숫자 1부터 10까지 숫자 중에서 홀수만 출력

BEGIN
	FOR NUM IN 1..10 LOOP
	IF MOD(NUM,2) = 1 THEN
		DBMS_OUTPUT.PUT_LINE('NUM : ' || NUM);
	END IF;
END LOOP;
END;
/


--커서(CURSOR) : SELECT 문 또는 DML 과 같은 SQL 구문 실행했을 때,
--해당 SQL을 처리하는 정보를 저장한 메모리 공간

--SELECT INTO : 조회 결과가 하나일 때 사용
DECLARE
	V_DEPT_ROW DEPT%ROWTYPE;
BEGIN
	SELECT DEPTNO,DNAME,LOC INTO V_DEPT_ROW
	FROM DEPT
	WHERE DEPTNO = 40;
	DBMS_OUTPUT.PUT_LINE('DEPTNO : ' || V_DEPT_ROW.DEPTNO);
	DBMS_OUTPUT.PUT_LINE('DNAME : ' || V_DEPT_ROW.DNAME);
	DBMS_OUTPUT.PUT_LINE('LOC : ' || V_DEPT_ROW.LOC);
END;
/

--조회 결과가 여러개의 행일 때
--명시적 커서
--1) 커서 선언
--2) 커서를 연다
--3) FETCH (커서에서 읽어온 데이터를 사용)
--4) 커서 닫기

DECLARE
	V_DEPT_ROW DEPT%ROWTYPE;

	--명시적 커서 선언
	CURSOR C1 IS
		SELECT DEPTNO,DNAME,LOC
		FROM DEPT
		WHERE DEPTNO = 40;
BEGIN
	--커서 열기
	OPEN C1;

	--FETCH
	FETCH C1 INTO V_DEPT_ROW;

	DBMS_OUTPUT.PUT_LINE('DEPTNO : ' || V_DEPT_ROW.DEPTNO);
	DBMS_OUTPUT.PUT_LINE('DNAME : ' || V_DEPT_ROW.DNAME);
	DBMS_OUTPUT.PUT_LINE('LOC : ' || V_DEPT_ROW.LOC);

	--커서 닫기
	CLOSE C1;
END;
/

--여러 행일 때
DECLARE
	V_DEPT_ROW DEPT%ROWTYPE;

	--명시적 커서 선언
	CURSOR C1 IS
		SELECT DEPTNO,DNAME,LOC
		FROM DEPT;
BEGIN
	--커서 열기
	OPEN C1;

	LOOP
		--FETCH
		FETCH C1 INTO V_DEPT_ROW;
	
		EXIT WHEN C1%NOTFOUND;
	
		DBMS_OUTPUT.PUT_LINE('DEPTNO : ' || V_DEPT_ROW.DEPTNO 
						|| ' DNAME : ' || V_DEPT_ROW.DNAME 
						|| ' LOC : ' || V_DEPT_ROW.LOC);
		
	END LOOP;
	
	--커서 닫기
	CLOSE C1;
END;
/

DECLARE
	--명시적 커서 선언
	CURSOR C1 IS
		SELECT DEPTNO, DNAME, LOC
		FROM DEPT;
BEGIN
	--커서 OPEN, FETCH, CLOSE 자동으로 실행
	FOR C1_ROW IN C1 LOOP
		DBMS_OUTPUT.PUT_LINE('DEPTNO : ' || C1_ROW.DEPTNO 
						|| ' DNAME : ' || C1_ROW.DNAME 
						|| ' LOC : ' || C1_ROW.LOC);
		
	END LOOP;
END;
/

--예외

DECLARE
	V_TAX NUMBER(1);
BEGIN
	SELECT DNAME INTO V_TAX
	FROM DEPT
	WHERE DEPTNO = 10;
EXCEPTION
	WHEN VALUE_ERROR THEN
		DBMS_OUTPUT.PUT_LINE('예외 처리 : 수치 또는 값 오류 발생');
END;
/

--저장 서브 프로그램
--1) 프로시저
--2) 트리거

CREATE OR REPLACE PROCEDURE PRO_NOPARAM
IS 
	V_EMPNO NUMBER (4) := 7788;
	V_ENAME VARCHAR2(10);
BEGIN
	V_ENAME := 'SCOTT';
	DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_EMPNO);
	DBMS_OUTPUT.PUT_LINE('V_ENAME : ' || V_ENAME);
END;
/

--프로시저를 익명 블록에서 실행
--SQL PLUS
-- =>EXECUTE PRO_NOPARAM

BEGIN
	PRO_NOPARAM;
END;

--트리거 : 데이터베이스 안의 특정 상황이나 동작, 이벤트가 발생하는 경우 자동으로 실행되는 기능 정의
